input {

  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # Parser principal pour les logs Mozilla
  grok {
    break_on_match => false
    patterns_dir => ["/etc/logstash/patterns"]
    match => [
      "message", "builder: %{DATA:builder}",
      "message", "slave: %{DATA:slave}",
      "message", "starttime: %{NUMBER:start_timestamp}",
      "message", "results: %{WORD:result_status}",
      "message", "buildid: %{DATA:build_id}",
      "message", "revision: %{DATA:revision}",
      "message", "========= Started %{DATA:step_name}.*elapsed: %{NUMBER:step_duration}",
      "message", "program finished with exit code %{NUMBER:exit_code}",
      "message", "elapsedTime=%{NUMBER:elapsed_time}",
      #"message", "Cancelled via self-serve by %{EMAIL:cancelled_by}"
    ]
  }
  
  # Conversion des timestamps
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }
  
  # Conversion des nombres
  mutate {
    convert => {
      "step_duration" => "float"
      "elapsed_time" => "float"
      "exit_code" => "integer"

    }
  }
  
  # Ajout de tags pour les builds annulÃ©s
  if [result_status] == "cancelled" {
    mutate {
      add_tag => ["cancelled_build"]
    }
  }
  
  # Extraction des suites de tests
  if [message] =~ /--mochitest-suite/ {
    grok {
      match => { "message" => "--mochitest-suite %{DATA:test_suites}" }
    }
    mutate {
      gsub => [ "test_suites", ",", " " ]
      split => { "test_suites" => " " }
    }
  }
}

output {

  elasticsearch {
    hosts => ["localhost:9200"]
    index => "mozilla-builds-%{+YYYY.MM.dd}"
    document_id => "%{build_id}-%{slave}"

  }
  
  # Pour debug
  stdout { 
    codec => rubydebug 
  }

}